#----------------------------------------------------------------------
# Set working directory
#----------------------------------------------------------------------
setwd("S:/CELL/Elec/Analysis")

#----------------------------------------------------------------------
# Load necessary libraries
#----------------------------------------------------------------------
library(umap)
library(dbscan)  # HDBSCAN is available in this library
library(ggplot2)
library(dplyr)
library(openxlsx)

#----------------------------------------------------------------------
# Step 1: Load the dataset
#----------------------------------------------------------------------
full_data <- read.csv("S:/CELL/Elec/Analysis/Masterlist-RNA-0-removed.csv")

# Assign gene IDs as row names
rownames(full_data) <- full_data[,1]

# Create a subset for analysis by removing the first two columns 
# (assuming they are GeneID and Description)
expression_data <- full_data[,-c(1,2)]
# Now, rownames(expression_data) should contain your gene IDs

#----------------------------------------------------------------------
# Step 2: Calculate variances (no filtering)
#----------------------------------------------------------------------
variances <- apply(expression_data, 1, var)

# Add the Variance column to full_data
full_data$Variance <- variances

# Plot histogram of variances
variance_plot <- ggplot(data.frame(Variance = variances), aes(x = Variance)) +
  geom_histogram(bins = 30, fill = "blue", color = "black") +
  labs(title = "Histogram of Gene Variances", x = "Variance", y = "Frequency") +
  theme(
    plot.title = element_text(hjust = 0.5),
    axis.line = element_line(size = 1, colour = "black"),
    axis.text = element_text(size = 18),
    axis.title = element_text(size = 20),
    panel.grid.major = element_line(size = 0.5),
    panel.grid.minor = element_blank(),
    axis.ticks = element_line(size = 1)
  )

# Save the variance plot
ggsave("S:/CELL/Elec/Analysis/variance_histogram.png", plot=variance_plot, width=10, height=8)
# Display the variance plot
print(variance_plot)

#----------------------------------------------------------------------
# (Filtering Step Removed)
# No thresholding or subsetting is performed here.
#----------------------------------------------------------------------

#----------------------------------------------------------------------
# Step 3: Scale the data by genes (rows) on the full dataset
#----------------------------------------------------------------------
numeric_data_transposed <- t(expression_data)

# Scale the data (performed on genes once transposed back)
scaled_data_transposed <- scale(numeric_data_transposed)

# Transpose back so genes are in rows, samples in columns
scaled_data <- t(scaled_data_transposed)

# Convert to data frame and restore row names
scaled_data_df <- as.data.frame(scaled_data)
rownames(scaled_data_df) <- rownames(expression_data)

# Combine the first two columns (identifiers) and variance back in
final_scaled_data <- cbind(
  full_data[, 1:2],      # GeneID, Description
  scaled_data_df,        # Scaled expression values
  Variance = variances   # Original variance
)

# Save the scaled data to Excel
write.xlsx(final_scaled_data, file = "S:/CELL/Elec/Analysis/Processed_Masterlist-RNA_scaled_with_Variance_mean.xlsx")
print("Full data (scaled) with variance has been written to Excel.")

#----------------------------------------------------------------------
# Step 4: UMAP Reduction (using all genes, no filtering)
#----------------------------------------------------------------------
umap_input <- scaled_data_df  # Only the scaled numeric data

# Ensure all data in umap_input is numeric
str(umap_input)  # Should show all columns as numeric

umap_result <- umap(umap_input, n_neighbors=38, min_dist=0.008, n_components=2)
save(umap_result, file= "S:/CELL/Elec/Analysis/umap_result.RData")

#----------------------------------------------------------------------
# Step 5: HDBSCAN Clustering
#----------------------------------------------------------------------
hdbscan_result <- hdbscan(umap_result$layout, minPts = 50)  # Adjust `minPts` as needed
save(hdbscan_result, file= "S:/CELL/Elec/Analysis/HDBSCAN_result.RData")

# Plotting UMAP results with HDBSCAN cluster assignments
umap_plot <- data.frame(
  UMAP1 = umap_result$layout[,1],
  UMAP2 = umap_result$layout[,2],
  Cluster = factor(hdbscan_result$cluster)
) %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = Cluster)) +
  geom_point(alpha = 0.5) +
  labs(
    title = "UMAP Reduction with HDBSCAN Clusters",
    color = "Cluster",
    x = "UMAP 1",
    y = "UMAP 2"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 28),
    axis.title = element_text(size = 20),
    axis.line = element_line(size = 1.5, colour = "black"),
    axis.text = element_text(size = 20),
    panel.grid.major = element_blank(),   # Remove major grid lines
    panel.grid.minor = element_blank()    # Remove minor grid lines
  ) +
  guides(
    color = guide_legend(
      override.aes = list(size = 6)       # Increase legend point size
    )
  )

# Save the UMAP plot
ggsave("S:/CELL/Elec/Analysis/umap_plot_with_hdbscan_clusters.png", plot=umap_plot, width=10, height=8)
# Display the UMAP plot
print(umap_plot)

#----------------------------------------------------------------------
# (Optional) Step 6: Principal Curve "Trajectory" on UMAP for Bulk Data
#----------------------------------------------------------------------
# If not installed, install princurve:
# install.packages("princurve")

library(princurve)

# Convert the UMAP layout to a matrix
umap_coords <- as.matrix(umap_result$layout)

# Fit the principal curve
pc_fit <- principal_curve(umap_coords)

# Extract coordinates and 'lambda' from the fitted curve
# 'lambda' is each sample's position along the principal curve
curve_order <- order(pc_fit$lambda)
curve_df <- data.frame(
  x = pc_fit$s[curve_order, 1],
  y = pc_fit$s[curve_order, 2]
)

# Identify the start and end points (smallest & largest lambda)
start_idx <- which.min(pc_fit$lambda)
end_idx   <- which.max(pc_fit$lambda)

# Coordinates of the start / end
start_coords <- pc_fit$s[start_idx, ]
end_coords   <- pc_fit$s[end_idx, ]

# Base UMAP + cluster plot
umap_plot <- data.frame(
  UMAP1   = umap_result$layout[,1],
  UMAP2   = umap_result$layout[,2],
  Cluster = factor(hdbscan_result$cluster)
) %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = Cluster)) +
  geom_point(alpha = 0.5) +
  labs(
    title = "UMAP Reduction with HDBSCAN Clusters",
    color = "Cluster",
    x = "UMAP 1",
    y = "UMAP 2"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 28),
    axis.title = element_text(size = 20),
    axis.line   = element_line(size = 1.5, colour = "black"),
    axis.text   = element_text(size = 20),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  guides(
    color = guide_legend(
      override.aes = list(size = 6)
    )
  )

# Add the principal curve line (sorted by 'lambda')
umap_plot_with_curve <- umap_plot +
  geom_path(
    data = curve_df,
    aes(x = x, y = y),
    size = 1.2,
    color = "black",
    inherit.aes = FALSE
  )

# OPTIONAL: highlight the start and end of the principal curve
umap_plot_with_curve <- umap_plot_with_curve +
  geom_point(
    aes(x = start_coords[1], y = start_coords[2]),
    color = "red",
    size = 4,
    shape = 17,         # triangle (or pick any other shape)
    inherit.aes = FALSE
  ) +
  geom_point(
    aes(x = end_coords[1], y = end_coords[2]),
    color = "blue",
    size = 4,
    shape = 17,
    inherit.aes = FALSE
  ) +
  geom_text(
    aes(x = start_coords[1], y = start_coords[2], label = "Start"),
    color = "red",
    size = 5,
    vjust = -1,
    inherit.aes = FALSE
  ) +
  geom_text(
    aes(x = end_coords[1], y = end_coords[2], label = "End"),
    color = "blue",
    size = 5,
    vjust = -1,
    inherit.aes = FALSE
  )

# Save & display
ggsave(
  "S:/CELL/Elec/Analysis/umap_plot_with_principal_curve.png",
  plot   = umap_plot_with_curve,
  width  = 10,
  height = 8
)
print(umap_plot_with_curve)


#----------------------------------------------------------------------
# Step 6 (Alternative): Create an interactive Plotly UMAP
#----------------------------------------------------------------------
# Creating interractive umap WITH SAME COLOUR SCALE AS THE STATIC UMAP

library(scales)

# Assuming your final UMAP data frame is something like:
umap_df <- data.frame(
  UMAP1   = umap_result$layout[,1],
  UMAP2   = umap_result$layout[,2],
  Cluster = factor(hdbscan_result$cluster),
  Gene    = rownames(umap_input)
)

# Get the number of unique clusters
num_clusters <- length(unique(umap_df$Cluster))

# This replicates ggplot's default hue scale for discrete data
my_ggplot_colors <- hue_pal()(num_clusters)


library(plotly)

fig <- plot_ly(
  data   = umap_df,
  x      = ~UMAP1,
  y      = ~UMAP2,
  color  = ~Cluster,
  text   = ~paste("Gene:", Gene, "<br>Cluster:", Cluster),
  type   = "scatter",
  mode   = "markers",
  marker = list(size = 5, opacity = 1),
  colors = my_ggplot_colors   # <--- Force Plotly to use your ggplot color palette
) %>%
  layout(
    title = list(text = "Interactive UMAP for Bulk RNA-seq Genes",
                 font = list(size = 20)),
    xaxis = list(
      title = list(text = "UMAP Dimension 1", font = list(size = 20)),
      tickfont = list(size = 20),
      showgrid = FALSE,
      zeroline = FALSE,
      showline = TRUE,
      linewidth = 2,
      linecolor = 'black'
    ),
    yaxis = list(
      title = list(text = "UMAP Dimension 2", font = list(size = 20)),
      tickfont = list(size = 20),
      showgrid = FALSE,
      zeroline = FALSE,
      showline = TRUE,
      linewidth = 2,
      linecolor = 'black'
    ),
    legend = list(
      title = list(text = "Clusters", font = list(size = 20, color = "black")),
      font = list(size = 16)
    )
  )

fig  # Displays the interactive plot




